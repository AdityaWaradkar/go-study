## **PHASE 1: FOUNDATIONS OF PROBLEM SOLVING**

### **Chapter 1: Algorithmic Thinking and Complexity**

**1.1** What an algorithm is\
**1.2** Problem-solving mindset for DSA\
**1.3** Input, output, and constraints\
**1.4** Time complexity concept\
**1.5** Space complexity concept\
**1.6** Big-O notation\
**1.7** Best, average, and worst cases\
**1.8** Constant factors and practical performance\
**1.9** Trade-offs between time and space

***

### **Chapter 2: Mathematical Foundations (Minimal but Necessary)**

**2.1** Integer arithmetic and overflow\
**2.2** Modulo arithmetic\
**2.3** Logarithms and exponentiation (conceptual)\
**2.4** Basic combinatorics (permutations, combinations)\
**2.5** Bitwise operations and use cases\
**2.6** Understanding recursion mathematically

<br>
<br>

## **PHASE 2: LINEAR DATA STRUCTURES**

### **Chapter 3: Arrays**

**3.1** Array definition and properties\
**3.2** Static vs dynamic arrays\
**3.3** Array indexing and bounds\
**3.4** Traversal patterns\
**3.5** Insertion and deletion costs\
**3.6** Common array problem patterns\
**3.7** Arrays vs slices in Go\
**3.8** Memory layout and cache behavior

***

### **Chapter 4: Strings**

**4.1** String representation\
**4.2** Strings as arrays of characters\
**4.3** Immutable vs mutable strings\
**4.4** Common string traversal techniques\
**4.5** Substrings and slicing\
**4.6** String comparison\
**4.7** String building efficiently\
**4.8** Unicode considerations (conceptual)

***

### **Chapter 5: Linked Lists**

**5.1** Singly linked list structure\
**5.2** Node representation\
**5.3** Traversal\
**5.4** Insertion operations\
**5.5** Deletion operations\
**5.6** Searching\
**5.7** Reversal techniques\
**5.8** Detecting cycles\
**5.9** Linked list vs array trade-offs

***

### **Chapter 6: Stacks**

**6.1** Stack definition and properties\
**6.2** Stack operations\
**6.3** Implementing stacks using arrays\
**6.4** Implementing stacks using linked lists\
**6.5** Call stack and recursion relationship\
**6.6** Balanced parentheses problem\
**6.7** Expression evaluation\
**6.8** Stack-based problem patterns

***

### **Chapter 7: Queues**

**7.1** Queue definition and properties\
**7.2** Queue operations\
**7.3** Implementing queues using arrays\
**7.4** Circular queues\
**7.5** Implementing queues using linked lists\
**7.6** Deque (double-ended queue)\
**7.7** Queue-based problem patterns

<br>
<br>


## **PHASE 3: NON-LINEAR DATA STRUCTURES**

### **Chapter 8: Hash Tables**

**8.1** Hash table concept\
**8.2** Hash functions\
**8.3** Collision handling techniques\
**8.4** Load factor and resizing\
**8.5** Hash table operations and complexity\
**8.6** Using maps in Go (conceptual alignment)\
**8.7** Hash-based problem patterns

***

### **Chapter 9: Trees**

**9.1** Tree terminology and structure\
**9.2** Binary trees\
**9.3** Tree traversal techniques\
**9.4** Recursive vs iterative traversal\
**9.5** Binary search trees (BST)\
**9.6** BST insertion, deletion, search\
**9.7** Height and depth\
**9.8** Balanced vs unbalanced trees\
**9.9** Tree-based problem patterns

***

### **Chapter 10: Heaps and Priority Queues**

**10.1** Heap definition\
**10.2** Min-heap vs max-heap\
**10.3** Heap representation using arrays\
**10.4** Heap insertion and deletion\
**10.5** Heapify operation\
**10.6** Priority queue use cases\
**10.7** Heap-based problem patterns

***

### **Chapter 11: Graphs**

**11.1** Graph terminology\
**11.2** Directed vs undirected graphs\
**11.3** Weighted vs unweighted graphs\
**11.4** Graph representation (adjacency list, matrix)\
**11.5** Graph traversal: BFS\
**11.6** Graph traversal: DFS\
**11.7** Connected components\
**11.8** Cycle detection\
**11.9** Topological sorting\
**11.10** Shortest path concepts (intro only)

<br>
<br>

## **PHASE 4: ALGORITHMIC TECHNIQUES**

### **Chapter 12: Recursion**

**12.1** Recursion fundamentals\
**12.2** Base cases and recursion trees\
**12.3** Tail recursion\
**12.4** Stack memory and recursion depth\
**12.5** Converting recursion to iteration\
**12.6** Recursive problem patterns

***

### **Chapter 13: Searching Algorithms**

**13.1** Linear search\
**13.2** Binary search\
**13.3** Binary search on answer\
**13.4** Searching in rotated arrays\
**13.5** Search space reduction techniques

***

### **Chapter 14: Sorting Algorithms**

**14.1** Why sorting matters\
**14.2** Bubble sort\
**14.3** Selection sort\
**14.4** Insertion sort\
**14.5** Merge sort\
**14.6** Quick sort\
**14.7** Heap sort\
**14.8** Stability and in-place sorting\
**14.9** Comparison-based sorting limits

***

### **Chapter 15: Two-Pointer and Sliding Window Techniques**

**15.1** Two-pointer concept\
**15.2** Opposite-direction pointers\
**15.3** Same-direction pointers\
**15.4** Sliding window basics\
**15.5** Fixed-size windows\
**15.6** Variable-size windows\
**15.7** Window-based optimization patterns

***

### **Chapter 16: Greedy Algorithms**

**16.1** Greedy strategy concept\
**16.2** When greedy works\
**16.3** Greedy choice property\
**16.4** Interval scheduling\
**16.5** Activity selection\
**16.6** Greedy pitfalls

<br>
<br>

## **PHASE 5: DYNAMIC PROGRAMMING**

### **Chapter 17: Dynamic Programming Foundations**

**17.1** Overlapping subproblems\
**17.2** Optimal substructure\
**17.3** Memoization vs tabulation\
**17.4** State definition\
**17.5** Transition relations\
**17.6** Time and space optimization

***

### **Chapter 18: Classic Dynamic Programming Problems**

**18.1** Fibonacci and variations\
**18.2** Knapsack problems\
**18.3** Coin change problems\
**18.4** Longest common subsequence\
**18.5** Longest increasing subsequence\
**18.6** Matrix chain multiplication\
**18.7** DP on grids

<br>
<br>

## **PHASE 6: ADVANCED BUT ESSENTIAL TOPICS**

### **Chapter 19: Backtracking**

**19.1** Backtracking concept\
**19.2** Decision trees\
**19.3** Constraint satisfaction\
**19.4** Permutations and combinations\
**19.5** Subset generation\
**19.6** Backtracking optimization

***

### **Chapter 20: Bit Manipulation**

**20.1** Binary number representation\
**20.2** Bitwise operators\
**20.3** Common bit tricks\
**20.4** Bit masking\
**20.5** XOR-based problem patterns

***
